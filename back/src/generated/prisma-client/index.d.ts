// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  chapter: (where?: ChapterWhereInput) => Promise<boolean>;
  story: (where?: StoryWhereInput) => Promise<boolean>;
  tag: (where?: TagWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  chapter: (where: ChapterWhereUniqueInput) => ChapterNullablePromise;
  chapters: (args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Chapter>;
  chaptersConnection: (args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ChapterConnectionPromise;
  story: (where: StoryWhereUniqueInput) => StoryNullablePromise;
  stories: (args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Story>;
  storiesConnection: (args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => StoryConnectionPromise;
  tag: (where: TagWhereUniqueInput) => TagNullablePromise;
  tags: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Tag>;
  tagsConnection: (args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => TagConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createChapter: (data: ChapterCreateInput) => ChapterPromise;
  updateChapter: (args: {
    data: ChapterUpdateInput;
    where: ChapterWhereUniqueInput;
  }) => ChapterPromise;
  updateManyChapters: (args: {
    data: ChapterUpdateManyMutationInput;
    where?: ChapterWhereInput;
  }) => BatchPayloadPromise;
  upsertChapter: (args: {
    where: ChapterWhereUniqueInput;
    create: ChapterCreateInput;
    update: ChapterUpdateInput;
  }) => ChapterPromise;
  deleteChapter: (where: ChapterWhereUniqueInput) => ChapterPromise;
  deleteManyChapters: (where?: ChapterWhereInput) => BatchPayloadPromise;
  createStory: (data: StoryCreateInput) => StoryPromise;
  updateStory: (args: {
    data: StoryUpdateInput;
    where: StoryWhereUniqueInput;
  }) => StoryPromise;
  updateManyStories: (args: {
    data: StoryUpdateManyMutationInput;
    where?: StoryWhereInput;
  }) => BatchPayloadPromise;
  upsertStory: (args: {
    where: StoryWhereUniqueInput;
    create: StoryCreateInput;
    update: StoryUpdateInput;
  }) => StoryPromise;
  deleteStory: (where: StoryWhereUniqueInput) => StoryPromise;
  deleteManyStories: (where?: StoryWhereInput) => BatchPayloadPromise;
  createTag: (data: TagCreateInput) => TagPromise;
  updateTag: (args: {
    data: TagUpdateInput;
    where: TagWhereUniqueInput;
  }) => TagPromise;
  updateManyTags: (args: {
    data: TagUpdateManyMutationInput;
    where?: TagWhereInput;
  }) => BatchPayloadPromise;
  upsertTag: (args: {
    where: TagWhereUniqueInput;
    create: TagCreateInput;
    update: TagUpdateInput;
  }) => TagPromise;
  deleteTag: (where: TagWhereUniqueInput) => TagPromise;
  deleteManyTags: (where?: TagWhereInput) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  chapter: (
    where?: ChapterSubscriptionWhereInput
  ) => ChapterSubscriptionPayloadSubscription;
  story: (
    where?: StorySubscriptionWhereInput
  ) => StorySubscriptionPayloadSubscription;
  tag: (
    where?: TagSubscriptionWhereInput
  ) => TagSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type StoryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "synopsis_ASC"
  | "synopsis_DESC"
  | "public_ASC"
  | "public_DESC"
  | "publicationDate_ASC"
  | "publicationDate_DESC";

export type TagOrderByInput = "id_ASC" | "id_DESC" | "name_ASC" | "name_DESC";

export type ChapterOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "title_ASC"
  | "title_DESC"
  | "number_ASC"
  | "number_DESC"
  | "publicationDate_ASC"
  | "publicationDate_DESC"
  | "content_ASC"
  | "content_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "password_ASC"
  | "password_DESC"
  | "email_ASC"
  | "email_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface ChapterUpdateManyWithoutStoryInput {
  create?: Maybe<
    ChapterCreateWithoutStoryInput[] | ChapterCreateWithoutStoryInput
  >;
  delete?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  set?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  disconnect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  update?: Maybe<
    | ChapterUpdateWithWhereUniqueWithoutStoryInput[]
    | ChapterUpdateWithWhereUniqueWithoutStoryInput
  >;
  upsert?: Maybe<
    | ChapterUpsertWithWhereUniqueWithoutStoryInput[]
    | ChapterUpsertWithWhereUniqueWithoutStoryInput
  >;
  deleteMany?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
  updateMany?: Maybe<
    | ChapterUpdateManyWithWhereNestedInput[]
    | ChapterUpdateManyWithWhereNestedInput
  >;
}

export type ChapterWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithWhereUniqueWithoutLikesChapterInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikesChapterDataInput;
}

export interface StoryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  synopsis?: Maybe<String>;
  synopsis_not?: Maybe<String>;
  synopsis_in?: Maybe<String[] | String>;
  synopsis_not_in?: Maybe<String[] | String>;
  synopsis_lt?: Maybe<String>;
  synopsis_lte?: Maybe<String>;
  synopsis_gt?: Maybe<String>;
  synopsis_gte?: Maybe<String>;
  synopsis_contains?: Maybe<String>;
  synopsis_not_contains?: Maybe<String>;
  synopsis_starts_with?: Maybe<String>;
  synopsis_not_starts_with?: Maybe<String>;
  synopsis_ends_with?: Maybe<String>;
  synopsis_not_ends_with?: Maybe<String>;
  public?: Maybe<Boolean>;
  public_not?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  publicationDate_not?: Maybe<DateTimeInput>;
  publicationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_lt?: Maybe<DateTimeInput>;
  publicationDate_lte?: Maybe<DateTimeInput>;
  publicationDate_gt?: Maybe<DateTimeInput>;
  publicationDate_gte?: Maybe<DateTimeInput>;
  tags_every?: Maybe<TagWhereInput>;
  tags_some?: Maybe<TagWhereInput>;
  tags_none?: Maybe<TagWhereInput>;
  chapters_every?: Maybe<ChapterWhereInput>;
  chapters_some?: Maybe<ChapterWhereInput>;
  chapters_none?: Maybe<ChapterWhereInput>;
  author?: Maybe<UserWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  AND?: Maybe<StoryWhereInput[] | StoryWhereInput>;
  OR?: Maybe<StoryWhereInput[] | StoryWhereInput>;
  NOT?: Maybe<StoryWhereInput[] | StoryWhereInput>;
}

export interface UserUpdateWithoutLikesChapterDataInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryUpdateManyWithoutLikedByInput>;
}

export interface TagWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  stories_every?: Maybe<StoryWhereInput>;
  stories_some?: Maybe<StoryWhereInput>;
  stories_none?: Maybe<StoryWhereInput>;
  AND?: Maybe<TagWhereInput[] | TagWhereInput>;
  OR?: Maybe<TagWhereInput[] | TagWhereInput>;
  NOT?: Maybe<TagWhereInput[] | TagWhereInput>;
}

export interface ChapterUpdateManyWithoutAuthorInput {
  create?: Maybe<
    ChapterCreateWithoutAuthorInput[] | ChapterCreateWithoutAuthorInput
  >;
  delete?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  set?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  disconnect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  update?: Maybe<
    | ChapterUpdateWithWhereUniqueWithoutAuthorInput[]
    | ChapterUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | ChapterUpsertWithWhereUniqueWithoutAuthorInput[]
    | ChapterUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
  updateMany?: Maybe<
    | ChapterUpdateManyWithWhereNestedInput[]
    | ChapterUpdateManyWithWhereNestedInput
  >;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  stories_every?: Maybe<StoryWhereInput>;
  stories_some?: Maybe<StoryWhereInput>;
  stories_none?: Maybe<StoryWhereInput>;
  chapters_every?: Maybe<ChapterWhereInput>;
  chapters_some?: Maybe<ChapterWhereInput>;
  chapters_none?: Maybe<ChapterWhereInput>;
  likesStory_every?: Maybe<StoryWhereInput>;
  likesStory_some?: Maybe<StoryWhereInput>;
  likesStory_none?: Maybe<StoryWhereInput>;
  likesChapter_every?: Maybe<ChapterWhereInput>;
  likesChapter_some?: Maybe<ChapterWhereInput>;
  likesChapter_none?: Maybe<ChapterWhereInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface StoryUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  tags?: Maybe<TagUpdateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutStoryInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesStoryInput>;
}

export interface UserUpsertWithoutChaptersInput {
  update: UserUpdateWithoutChaptersDataInput;
  create: UserCreateWithoutChaptersInput;
}

export interface TagUpdateManyWithoutStoriesInput {
  create?: Maybe<TagCreateWithoutStoriesInput[] | TagCreateWithoutStoriesInput>;
  delete?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  set?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  disconnect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
  update?: Maybe<
    | TagUpdateWithWhereUniqueWithoutStoriesInput[]
    | TagUpdateWithWhereUniqueWithoutStoriesInput
  >;
  upsert?: Maybe<
    | TagUpsertWithWhereUniqueWithoutStoriesInput[]
    | TagUpsertWithWhereUniqueWithoutStoriesInput
  >;
  deleteMany?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  updateMany?: Maybe<
    TagUpdateManyWithWhereNestedInput[] | TagUpdateManyWithWhereNestedInput
  >;
}

export interface ChapterUpdateWithWhereUniqueWithoutAuthorInput {
  where: ChapterWhereUniqueInput;
  data: ChapterUpdateWithoutAuthorDataInput;
}

export interface TagUpdateWithWhereUniqueWithoutStoriesInput {
  where: TagWhereUniqueInput;
  data: TagUpdateWithoutStoriesDataInput;
}

export interface TagSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<TagWhereInput>;
  AND?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  OR?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
  NOT?: Maybe<TagSubscriptionWhereInput[] | TagSubscriptionWhereInput>;
}

export interface TagUpdateWithoutStoriesDataInput {
  name?: Maybe<String>;
}

export interface ChapterSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ChapterWhereInput>;
  AND?: Maybe<ChapterSubscriptionWhereInput[] | ChapterSubscriptionWhereInput>;
  OR?: Maybe<ChapterSubscriptionWhereInput[] | ChapterSubscriptionWhereInput>;
  NOT?: Maybe<ChapterSubscriptionWhereInput[] | ChapterSubscriptionWhereInput>;
}

export interface TagUpsertWithWhereUniqueWithoutStoriesInput {
  where: TagWhereUniqueInput;
  update: TagUpdateWithoutStoriesDataInput;
  create: TagCreateWithoutStoriesInput;
}

export interface UserUpdateInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryUpdateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterUpdateManyWithoutLikedByInput>;
}

export interface TagScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  AND?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  OR?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
  NOT?: Maybe<TagScalarWhereInput[] | TagScalarWhereInput>;
}

export type StoryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface TagUpdateManyWithWhereNestedInput {
  where: TagScalarWhereInput;
  data: TagUpdateManyDataInput;
}

export interface StoryUpsertWithWhereUniqueWithoutTagsInput {
  where: StoryWhereUniqueInput;
  update: StoryUpdateWithoutTagsDataInput;
  create: StoryCreateWithoutTagsInput;
}

export interface TagUpdateManyDataInput {
  name?: Maybe<String>;
}

export type TagWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  name?: Maybe<String>;
}>;

export interface StoryUpdateManyMutationInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
}

export interface StoryUpdateManyWithoutTagsInput {
  create?: Maybe<StoryCreateWithoutTagsInput[] | StoryCreateWithoutTagsInput>;
  delete?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  set?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  disconnect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  update?: Maybe<
    | StoryUpdateWithWhereUniqueWithoutTagsInput[]
    | StoryUpdateWithWhereUniqueWithoutTagsInput
  >;
  upsert?: Maybe<
    | StoryUpsertWithWhereUniqueWithoutTagsInput[]
    | StoryUpsertWithWhereUniqueWithoutTagsInput
  >;
  deleteMany?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  updateMany?: Maybe<
    StoryUpdateManyWithWhereNestedInput[] | StoryUpdateManyWithWhereNestedInput
  >;
}

export interface ChapterUpdateWithWhereUniqueWithoutStoryInput {
  where: ChapterWhereUniqueInput;
  data: ChapterUpdateWithoutStoryDataInput;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ChapterUpdateWithoutStoryDataInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneWithoutChaptersInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesChapterInput>;
}

export interface StoryCreateManyWithoutTagsInput {
  create?: Maybe<StoryCreateWithoutTagsInput[] | StoryCreateWithoutTagsInput>;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
}

export interface UserUpdateManyWithoutLikesChapterInput {
  create?: Maybe<
    UserCreateWithoutLikesChapterInput[] | UserCreateWithoutLikesChapterInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikesChapterInput[]
    | UserUpdateWithWhereUniqueWithoutLikesChapterInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikesChapterInput[]
    | UserUpsertWithWhereUniqueWithoutLikesChapterInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateOneWithoutChaptersInput {
  create?: Maybe<UserCreateWithoutChaptersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StoryUpdateInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  tags?: Maybe<TagUpdateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutStoryInput>;
  author?: Maybe<UserUpdateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesStoryInput>;
}

export interface StoryCreateManyWithoutAuthorInput {
  create?: Maybe<
    StoryCreateWithoutAuthorInput[] | StoryCreateWithoutAuthorInput
  >;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
}

export interface ChapterWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  publicationDate_not?: Maybe<DateTimeInput>;
  publicationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_lt?: Maybe<DateTimeInput>;
  publicationDate_lte?: Maybe<DateTimeInput>;
  publicationDate_gt?: Maybe<DateTimeInput>;
  publicationDate_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  author?: Maybe<UserWhereInput>;
  story?: Maybe<StoryWhereInput>;
  likedBy_every?: Maybe<UserWhereInput>;
  likedBy_some?: Maybe<UserWhereInput>;
  likedBy_none?: Maybe<UserWhereInput>;
  AND?: Maybe<ChapterWhereInput[] | ChapterWhereInput>;
  OR?: Maybe<ChapterWhereInput[] | ChapterWhereInput>;
  NOT?: Maybe<ChapterWhereInput[] | ChapterWhereInput>;
}

export interface TagCreateManyWithoutStoriesInput {
  create?: Maybe<TagCreateWithoutStoriesInput[] | TagCreateWithoutStoriesInput>;
  connect?: Maybe<TagWhereUniqueInput[] | TagWhereUniqueInput>;
}

export interface StoryCreateInput {
  id?: Maybe<ID_Input>;
  title: String;
  synopsis?: Maybe<String>;
  public: Boolean;
  publicationDate: DateTimeInput;
  tags?: Maybe<TagCreateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterCreateManyWithoutStoryInput>;
  author?: Maybe<UserCreateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikesStoryInput>;
}

export interface ChapterCreateManyWithoutStoryInput {
  create?: Maybe<
    ChapterCreateWithoutStoryInput[] | ChapterCreateWithoutStoryInput
  >;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
}

export interface ChapterUpdateManyMutationInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
}

export interface UserCreateManyWithoutLikesChapterInput {
  create?: Maybe<
    UserCreateWithoutLikesChapterInput[] | UserCreateWithoutLikesChapterInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface ChapterUpdateWithoutAuthorDataInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  story?: Maybe<StoryUpdateOneRequiredWithoutChaptersInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesChapterInput>;
}

export interface ChapterCreateManyWithoutAuthorInput {
  create?: Maybe<
    ChapterCreateWithoutAuthorInput[] | ChapterCreateWithoutAuthorInput
  >;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
}

export interface StoryUpdateOneRequiredWithoutChaptersInput {
  create?: Maybe<StoryCreateWithoutChaptersInput>;
  update?: Maybe<StoryUpdateWithoutChaptersDataInput>;
  upsert?: Maybe<StoryUpsertWithoutChaptersInput>;
  connect?: Maybe<StoryWhereUniqueInput>;
}

export interface StoryCreateOneWithoutChaptersInput {
  create?: Maybe<StoryCreateWithoutChaptersInput>;
  connect?: Maybe<StoryWhereUniqueInput>;
}

export interface StoryUpdateWithoutChaptersDataInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  tags?: Maybe<TagUpdateManyWithoutStoriesInput>;
  author?: Maybe<UserUpdateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesStoryInput>;
}

export interface UserCreateOneWithoutStoriesInput {
  create?: Maybe<UserCreateWithoutStoriesInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface UserUpdateOneWithoutStoriesInput {
  create?: Maybe<UserCreateWithoutStoriesInput>;
  update?: Maybe<UserUpdateWithoutStoriesDataInput>;
  upsert?: Maybe<UserUpsertWithoutStoriesInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StoryCreateManyWithoutLikedByInput {
  create?: Maybe<
    StoryCreateWithoutLikedByInput[] | StoryCreateWithoutLikedByInput
  >;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
}

export interface UserUpdateWithoutStoriesDataInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  chapters?: Maybe<ChapterUpdateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryUpdateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterUpdateManyWithoutLikedByInput>;
}

export interface ChapterCreateManyWithoutLikedByInput {
  create?: Maybe<
    ChapterCreateWithoutLikedByInput[] | ChapterCreateWithoutLikedByInput
  >;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
}

export interface StoryUpdateManyWithoutLikedByInput {
  create?: Maybe<
    StoryCreateWithoutLikedByInput[] | StoryCreateWithoutLikedByInput
  >;
  delete?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  set?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  disconnect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  update?: Maybe<
    | StoryUpdateWithWhereUniqueWithoutLikedByInput[]
    | StoryUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | StoryUpsertWithWhereUniqueWithoutLikedByInput[]
    | StoryUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  updateMany?: Maybe<
    StoryUpdateManyWithWhereNestedInput[] | StoryUpdateManyWithWhereNestedInput
  >;
}

export interface UserCreateManyWithoutLikesStoryInput {
  create?: Maybe<
    UserCreateWithoutLikesStoryInput[] | UserCreateWithoutLikesStoryInput
  >;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
}

export interface StoryUpdateWithWhereUniqueWithoutLikedByInput {
  where: StoryWhereUniqueInput;
  data: StoryUpdateWithoutLikedByDataInput;
}

export interface ChapterUpdateInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneWithoutChaptersInput>;
  story?: Maybe<StoryUpdateOneRequiredWithoutChaptersInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesChapterInput>;
}

export interface StoryUpdateWithoutLikedByDataInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  tags?: Maybe<TagUpdateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutStoryInput>;
  author?: Maybe<UserUpdateOneWithoutStoriesInput>;
}

export interface UserUpdateWithoutChaptersDataInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryUpdateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterUpdateManyWithoutLikedByInput>;
}

export interface StoryUpsertWithWhereUniqueWithoutLikedByInput {
  where: StoryWhereUniqueInput;
  update: StoryUpdateWithoutLikedByDataInput;
  create: StoryCreateWithoutLikedByInput;
}

export interface StoryUpdateWithWhereUniqueWithoutAuthorInput {
  where: StoryWhereUniqueInput;
  data: StoryUpdateWithoutAuthorDataInput;
}

export interface StoryScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  synopsis?: Maybe<String>;
  synopsis_not?: Maybe<String>;
  synopsis_in?: Maybe<String[] | String>;
  synopsis_not_in?: Maybe<String[] | String>;
  synopsis_lt?: Maybe<String>;
  synopsis_lte?: Maybe<String>;
  synopsis_gt?: Maybe<String>;
  synopsis_gte?: Maybe<String>;
  synopsis_contains?: Maybe<String>;
  synopsis_not_contains?: Maybe<String>;
  synopsis_starts_with?: Maybe<String>;
  synopsis_not_starts_with?: Maybe<String>;
  synopsis_ends_with?: Maybe<String>;
  synopsis_not_ends_with?: Maybe<String>;
  public?: Maybe<Boolean>;
  public_not?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  publicationDate_not?: Maybe<DateTimeInput>;
  publicationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_lt?: Maybe<DateTimeInput>;
  publicationDate_lte?: Maybe<DateTimeInput>;
  publicationDate_gt?: Maybe<DateTimeInput>;
  publicationDate_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  OR?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  NOT?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
}

export interface StorySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<StoryWhereInput>;
  AND?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
  OR?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
  NOT?: Maybe<StorySubscriptionWhereInput[] | StorySubscriptionWhereInput>;
}

export interface StoryUpdateManyWithWhereNestedInput {
  where: StoryScalarWhereInput;
  data: StoryUpdateManyDataInput;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  email: String;
  stories?: Maybe<StoryCreateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterCreateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryCreateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterCreateManyWithoutLikedByInput>;
}

export interface StoryUpdateManyDataInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
}

export interface StoryUpdateWithoutTagsDataInput {
  title?: Maybe<String>;
  synopsis?: Maybe<String>;
  public?: Maybe<Boolean>;
  publicationDate?: Maybe<DateTimeInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutStoryInput>;
  author?: Maybe<UserUpdateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserUpdateManyWithoutLikesStoryInput>;
}

export interface ChapterUpdateManyWithoutLikedByInput {
  create?: Maybe<
    ChapterCreateWithoutLikedByInput[] | ChapterCreateWithoutLikedByInput
  >;
  delete?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  connect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  set?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  disconnect?: Maybe<ChapterWhereUniqueInput[] | ChapterWhereUniqueInput>;
  update?: Maybe<
    | ChapterUpdateWithWhereUniqueWithoutLikedByInput[]
    | ChapterUpdateWithWhereUniqueWithoutLikedByInput
  >;
  upsert?: Maybe<
    | ChapterUpsertWithWhereUniqueWithoutLikedByInput[]
    | ChapterUpsertWithWhereUniqueWithoutLikedByInput
  >;
  deleteMany?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
  updateMany?: Maybe<
    | ChapterUpdateManyWithWhereNestedInput[]
    | ChapterUpdateManyWithWhereNestedInput
  >;
}

export interface TagUpdateInput {
  name?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutTagsInput>;
}

export interface ChapterUpdateWithWhereUniqueWithoutLikedByInput {
  where: ChapterWhereUniqueInput;
  data: ChapterUpdateWithoutLikedByDataInput;
}

export interface TagCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  stories?: Maybe<StoryCreateManyWithoutTagsInput>;
}

export interface ChapterUpdateWithoutLikedByDataInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  author?: Maybe<UserUpdateOneWithoutChaptersInput>;
  story?: Maybe<StoryUpdateOneRequiredWithoutChaptersInput>;
}

export interface UserCreateWithoutChaptersInput {
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  email: String;
  stories?: Maybe<StoryCreateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryCreateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterCreateManyWithoutLikedByInput>;
}

export interface ChapterUpsertWithWhereUniqueWithoutLikedByInput {
  where: ChapterWhereUniqueInput;
  update: ChapterUpdateWithoutLikedByDataInput;
  create: ChapterCreateWithoutLikedByInput;
}

export interface TagCreateWithoutStoriesInput {
  id?: Maybe<ID_Input>;
  name: String;
}

export interface ChapterScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  number?: Maybe<Int>;
  number_not?: Maybe<Int>;
  number_in?: Maybe<Int[] | Int>;
  number_not_in?: Maybe<Int[] | Int>;
  number_lt?: Maybe<Int>;
  number_lte?: Maybe<Int>;
  number_gt?: Maybe<Int>;
  number_gte?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  publicationDate_not?: Maybe<DateTimeInput>;
  publicationDate_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  publicationDate_lt?: Maybe<DateTimeInput>;
  publicationDate_lte?: Maybe<DateTimeInput>;
  publicationDate_gt?: Maybe<DateTimeInput>;
  publicationDate_gte?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
  content_not?: Maybe<String>;
  content_in?: Maybe<String[] | String>;
  content_not_in?: Maybe<String[] | String>;
  content_lt?: Maybe<String>;
  content_lte?: Maybe<String>;
  content_gt?: Maybe<String>;
  content_gte?: Maybe<String>;
  content_contains?: Maybe<String>;
  content_not_contains?: Maybe<String>;
  content_starts_with?: Maybe<String>;
  content_not_starts_with?: Maybe<String>;
  content_ends_with?: Maybe<String>;
  content_not_ends_with?: Maybe<String>;
  AND?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
  OR?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
  NOT?: Maybe<ChapterScalarWhereInput[] | ChapterScalarWhereInput>;
}

export interface UserCreateWithoutLikesChapterInput {
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  email: String;
  stories?: Maybe<StoryCreateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterCreateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryCreateManyWithoutLikedByInput>;
}

export interface ChapterUpdateManyWithWhereNestedInput {
  where: ChapterScalarWhereInput;
  data: ChapterUpdateManyDataInput;
}

export interface StoryCreateWithoutChaptersInput {
  id?: Maybe<ID_Input>;
  title: String;
  synopsis?: Maybe<String>;
  public: Boolean;
  publicationDate: DateTimeInput;
  tags?: Maybe<TagCreateManyWithoutStoriesInput>;
  author?: Maybe<UserCreateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikesStoryInput>;
}

export interface ChapterUpdateManyDataInput {
  title?: Maybe<String>;
  number?: Maybe<Int>;
  publicationDate?: Maybe<DateTimeInput>;
  content?: Maybe<String>;
}

export interface StoryCreateWithoutLikedByInput {
  id?: Maybe<ID_Input>;
  title: String;
  synopsis?: Maybe<String>;
  public: Boolean;
  publicationDate: DateTimeInput;
  tags?: Maybe<TagCreateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterCreateManyWithoutStoryInput>;
  author?: Maybe<UserCreateOneWithoutStoriesInput>;
}

export interface UserUpsertWithoutStoriesInput {
  update: UserUpdateWithoutStoriesDataInput;
  create: UserCreateWithoutStoriesInput;
}

export interface UserCreateWithoutLikesStoryInput {
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  email: String;
  stories?: Maybe<StoryCreateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterCreateManyWithoutAuthorInput>;
  likesChapter?: Maybe<ChapterCreateManyWithoutLikedByInput>;
}

export interface UserUpdateManyWithoutLikesStoryInput {
  create?: Maybe<
    UserCreateWithoutLikesStoryInput[] | UserCreateWithoutLikesStoryInput
  >;
  delete?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  connect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  set?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  disconnect?: Maybe<UserWhereUniqueInput[] | UserWhereUniqueInput>;
  update?: Maybe<
    | UserUpdateWithWhereUniqueWithoutLikesStoryInput[]
    | UserUpdateWithWhereUniqueWithoutLikesStoryInput
  >;
  upsert?: Maybe<
    | UserUpsertWithWhereUniqueWithoutLikesStoryInput[]
    | UserUpsertWithWhereUniqueWithoutLikesStoryInput
  >;
  deleteMany?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  updateMany?: Maybe<
    UserUpdateManyWithWhereNestedInput[] | UserUpdateManyWithWhereNestedInput
  >;
}

export interface StoryUpdateManyWithoutAuthorInput {
  create?: Maybe<
    StoryCreateWithoutAuthorInput[] | StoryCreateWithoutAuthorInput
  >;
  delete?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  connect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  set?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  disconnect?: Maybe<StoryWhereUniqueInput[] | StoryWhereUniqueInput>;
  update?: Maybe<
    | StoryUpdateWithWhereUniqueWithoutAuthorInput[]
    | StoryUpdateWithWhereUniqueWithoutAuthorInput
  >;
  upsert?: Maybe<
    | StoryUpsertWithWhereUniqueWithoutAuthorInput[]
    | StoryUpsertWithWhereUniqueWithoutAuthorInput
  >;
  deleteMany?: Maybe<StoryScalarWhereInput[] | StoryScalarWhereInput>;
  updateMany?: Maybe<
    StoryUpdateManyWithWhereNestedInput[] | StoryUpdateManyWithWhereNestedInput
  >;
}

export interface UserUpdateWithWhereUniqueWithoutLikesStoryInput {
  where: UserWhereUniqueInput;
  data: UserUpdateWithoutLikesStoryDataInput;
}

export interface UserUpdateManyMutationInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserUpdateWithoutLikesStoryDataInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
  stories?: Maybe<StoryUpdateManyWithoutAuthorInput>;
  chapters?: Maybe<ChapterUpdateManyWithoutAuthorInput>;
  likesChapter?: Maybe<ChapterUpdateManyWithoutLikedByInput>;
}

export interface StoryUpdateWithWhereUniqueWithoutTagsInput {
  where: StoryWhereUniqueInput;
  data: StoryUpdateWithoutTagsDataInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikesStoryInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikesStoryDataInput;
  create: UserCreateWithoutLikesStoryInput;
}

export interface ChapterCreateInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  number: Int;
  publicationDate: DateTimeInput;
  content: String;
  author?: Maybe<UserCreateOneWithoutChaptersInput>;
  story: StoryCreateOneWithoutChaptersInput;
  likedBy?: Maybe<UserCreateManyWithoutLikesChapterInput>;
}

export interface UserScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  AND?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  OR?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
  NOT?: Maybe<UserScalarWhereInput[] | UserScalarWhereInput>;
}

export interface ChapterCreateWithoutStoryInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  number: Int;
  publicationDate: DateTimeInput;
  content: String;
  author?: Maybe<UserCreateOneWithoutChaptersInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikesChapterInput>;
}

export interface UserUpdateManyWithWhereNestedInput {
  where: UserScalarWhereInput;
  data: UserUpdateManyDataInput;
}

export interface UserCreateWithoutStoriesInput {
  id?: Maybe<ID_Input>;
  name: String;
  password: String;
  email: String;
  chapters?: Maybe<ChapterCreateManyWithoutAuthorInput>;
  likesStory?: Maybe<StoryCreateManyWithoutLikedByInput>;
  likesChapter?: Maybe<ChapterCreateManyWithoutLikedByInput>;
}

export interface UserUpdateManyDataInput {
  name?: Maybe<String>;
  password?: Maybe<String>;
  email?: Maybe<String>;
}

export interface UserUpdateOneWithoutChaptersInput {
  create?: Maybe<UserCreateWithoutChaptersInput>;
  update?: Maybe<UserUpdateWithoutChaptersDataInput>;
  upsert?: Maybe<UserUpsertWithoutChaptersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface StoryUpsertWithoutChaptersInput {
  update: StoryUpdateWithoutChaptersDataInput;
  create: StoryCreateWithoutChaptersInput;
}

export interface TagUpdateManyMutationInput {
  name?: Maybe<String>;
}

export interface StoryUpsertWithWhereUniqueWithoutAuthorInput {
  where: StoryWhereUniqueInput;
  update: StoryUpdateWithoutAuthorDataInput;
  create: StoryCreateWithoutAuthorInput;
}

export interface ChapterUpsertWithWhereUniqueWithoutStoryInput {
  where: ChapterWhereUniqueInput;
  update: ChapterUpdateWithoutStoryDataInput;
  create: ChapterCreateWithoutStoryInput;
}

export interface UserUpsertWithWhereUniqueWithoutLikesChapterInput {
  where: UserWhereUniqueInput;
  update: UserUpdateWithoutLikesChapterDataInput;
  create: UserCreateWithoutLikesChapterInput;
}

export interface ChapterUpsertWithWhereUniqueWithoutAuthorInput {
  where: ChapterWhereUniqueInput;
  update: ChapterUpdateWithoutAuthorDataInput;
  create: ChapterCreateWithoutAuthorInput;
}

export interface StoryCreateWithoutTagsInput {
  id?: Maybe<ID_Input>;
  title: String;
  synopsis?: Maybe<String>;
  public: Boolean;
  publicationDate: DateTimeInput;
  chapters?: Maybe<ChapterCreateManyWithoutStoryInput>;
  author?: Maybe<UserCreateOneWithoutStoriesInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikesStoryInput>;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ChapterCreateWithoutLikedByInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  number: Int;
  publicationDate: DateTimeInput;
  content: String;
  author?: Maybe<UserCreateOneWithoutChaptersInput>;
  story: StoryCreateOneWithoutChaptersInput;
}

export interface ChapterCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title?: Maybe<String>;
  number: Int;
  publicationDate: DateTimeInput;
  content: String;
  story: StoryCreateOneWithoutChaptersInput;
  likedBy?: Maybe<UserCreateManyWithoutLikesChapterInput>;
}

export interface StoryCreateWithoutAuthorInput {
  id?: Maybe<ID_Input>;
  title: String;
  synopsis?: Maybe<String>;
  public: Boolean;
  publicationDate: DateTimeInput;
  tags?: Maybe<TagCreateManyWithoutStoriesInput>;
  chapters?: Maybe<ChapterCreateManyWithoutStoryInput>;
  likedBy?: Maybe<UserCreateManyWithoutLikesStoryInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  name: String;
  password: String;
  email: String;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
}

export interface AggregateChapter {
  count: Int;
}

export interface AggregateChapterPromise
  extends Promise<AggregateChapter>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateChapterSubscription
  extends Promise<AsyncIterator<AggregateChapter>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Story {
  id: ID_Output;
  title: String;
  synopsis?: String;
  public: Boolean;
  publicationDate: DateTimeOutput;
}

export interface StoryPromise extends Promise<Story>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  synopsis: () => Promise<String>;
  public: () => Promise<Boolean>;
  publicationDate: () => Promise<DateTimeOutput>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StorySubscription
  extends Promise<AsyncIterator<Story>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  synopsis: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  publicationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  tags: <T = Promise<AsyncIterator<TagSubscription>>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = Promise<AsyncIterator<ChapterSubscription>>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserSubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StoryNullablePromise
  extends Promise<Story | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  synopsis: () => Promise<String>;
  public: () => Promise<Boolean>;
  publicationDate: () => Promise<DateTimeOutput>;
  tags: <T = FragmentableArray<Tag>>(args?: {
    where?: TagWhereInput;
    orderBy?: TagOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  author: <T = UserPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface StoryConnection {
  pageInfo: PageInfo;
  edges: StoryEdge[];
}

export interface StoryConnectionPromise
  extends Promise<StoryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<StoryEdge>>() => T;
  aggregate: <T = AggregateStoryPromise>() => T;
}

export interface StoryConnectionSubscription
  extends Promise<AsyncIterator<StoryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<StoryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateStorySubscription>() => T;
}

export interface TagSubscriptionPayload {
  mutation: MutationType;
  node: Tag;
  updatedFields: String[];
  previousValues: TagPreviousValues;
}

export interface TagSubscriptionPayloadPromise
  extends Promise<TagSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = TagPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = TagPreviousValuesPromise>() => T;
}

export interface TagSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<TagSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = TagSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = TagPreviousValuesSubscription>() => T;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface ChapterEdge {
  node: Chapter;
  cursor: String;
}

export interface ChapterEdgePromise extends Promise<ChapterEdge>, Fragmentable {
  node: <T = ChapterPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ChapterEdgeSubscription
  extends Promise<AsyncIterator<ChapterEdge>>,
    Fragmentable {
  node: <T = ChapterSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface User {
  id: ID_Output;
  name: String;
  password: String;
  email: String;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesStory: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesChapter: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  email: () => Promise<AsyncIterator<String>>;
  stories: <T = Promise<AsyncIterator<StorySubscription>>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = Promise<AsyncIterator<ChapterSubscription>>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesStory: <T = Promise<AsyncIterator<StorySubscription>>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesChapter: <T = Promise<AsyncIterator<ChapterSubscription>>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  password: () => Promise<String>;
  email: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  chapters: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesStory: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  likesChapter: <T = FragmentableArray<Chapter>>(args?: {
    where?: ChapterWhereInput;
    orderBy?: ChapterOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface Tag {
  id: ID_Output;
  name: String;
}

export interface TagPromise extends Promise<Tag>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagSubscription
  extends Promise<AsyncIterator<Tag>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  stories: <T = Promise<AsyncIterator<StorySubscription>>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagNullablePromise extends Promise<Tag | null>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  stories: <T = FragmentableArray<Story>>(args?: {
    where?: StoryWhereInput;
    orderBy?: StoryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ChapterConnection {
  pageInfo: PageInfo;
  edges: ChapterEdge[];
}

export interface ChapterConnectionPromise
  extends Promise<ChapterConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ChapterEdge>>() => T;
  aggregate: <T = AggregateChapterPromise>() => T;
}

export interface ChapterConnectionSubscription
  extends Promise<AsyncIterator<ChapterConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ChapterEdgeSubscription>>>() => T;
  aggregate: <T = AggregateChapterSubscription>() => T;
}

export interface AggregateTag {
  count: Int;
}

export interface AggregateTagPromise
  extends Promise<AggregateTag>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateTagSubscription
  extends Promise<AsyncIterator<AggregateTag>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Chapter {
  id: ID_Output;
  title?: String;
  number: Int;
  publicationDate: DateTimeOutput;
  content: String;
}

export interface ChapterPromise extends Promise<Chapter>, Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  publicationDate: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
  story: <T = StoryPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChapterSubscription
  extends Promise<AsyncIterator<Chapter>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  publicationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
  author: <T = UserSubscription>() => T;
  story: <T = StorySubscription>() => T;
  likedBy: <T = Promise<AsyncIterator<UserSubscription>>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ChapterNullablePromise
  extends Promise<Chapter | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  publicationDate: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
  author: <T = UserPromise>() => T;
  story: <T = StoryPromise>() => T;
  likedBy: <T = FragmentableArray<User>>(args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface TagConnection {
  pageInfo: PageInfo;
  edges: TagEdge[];
}

export interface TagConnectionPromise
  extends Promise<TagConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<TagEdge>>() => T;
  aggregate: <T = AggregateTagPromise>() => T;
}

export interface TagConnectionSubscription
  extends Promise<AsyncIterator<TagConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<TagEdgeSubscription>>>() => T;
  aggregate: <T = AggregateTagSubscription>() => T;
}

export interface ChapterSubscriptionPayload {
  mutation: MutationType;
  node: Chapter;
  updatedFields: String[];
  previousValues: ChapterPreviousValues;
}

export interface ChapterSubscriptionPayloadPromise
  extends Promise<ChapterSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ChapterPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ChapterPreviousValuesPromise>() => T;
}

export interface ChapterSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ChapterSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ChapterSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ChapterPreviousValuesSubscription>() => T;
}

export interface StoryEdge {
  node: Story;
  cursor: String;
}

export interface StoryEdgePromise extends Promise<StoryEdge>, Fragmentable {
  node: <T = StoryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface StoryEdgeSubscription
  extends Promise<AsyncIterator<StoryEdge>>,
    Fragmentable {
  node: <T = StorySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface StoryPreviousValues {
  id: ID_Output;
  title: String;
  synopsis?: String;
  public: Boolean;
  publicationDate: DateTimeOutput;
}

export interface StoryPreviousValuesPromise
  extends Promise<StoryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  synopsis: () => Promise<String>;
  public: () => Promise<Boolean>;
  publicationDate: () => Promise<DateTimeOutput>;
}

export interface StoryPreviousValuesSubscription
  extends Promise<AsyncIterator<StoryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  synopsis: () => Promise<AsyncIterator<String>>;
  public: () => Promise<AsyncIterator<Boolean>>;
  publicationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface StorySubscriptionPayload {
  mutation: MutationType;
  node: Story;
  updatedFields: String[];
  previousValues: StoryPreviousValues;
}

export interface StorySubscriptionPayloadPromise
  extends Promise<StorySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = StoryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = StoryPreviousValuesPromise>() => T;
}

export interface StorySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<StorySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = StorySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = StoryPreviousValuesSubscription>() => T;
}

export interface TagPreviousValues {
  id: ID_Output;
  name: String;
}

export interface TagPreviousValuesPromise
  extends Promise<TagPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
}

export interface TagPreviousValuesSubscription
  extends Promise<AsyncIterator<TagPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
}

export interface ChapterPreviousValues {
  id: ID_Output;
  title?: String;
  number: Int;
  publicationDate: DateTimeOutput;
  content: String;
}

export interface ChapterPreviousValuesPromise
  extends Promise<ChapterPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  title: () => Promise<String>;
  number: () => Promise<Int>;
  publicationDate: () => Promise<DateTimeOutput>;
  content: () => Promise<String>;
}

export interface ChapterPreviousValuesSubscription
  extends Promise<AsyncIterator<ChapterPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  title: () => Promise<AsyncIterator<String>>;
  number: () => Promise<AsyncIterator<Int>>;
  publicationDate: () => Promise<AsyncIterator<DateTimeOutput>>;
  content: () => Promise<AsyncIterator<String>>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface AggregateStory {
  count: Int;
}

export interface AggregateStoryPromise
  extends Promise<AggregateStory>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateStorySubscription
  extends Promise<AsyncIterator<AggregateStory>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface TagEdge {
  node: Tag;
  cursor: String;
}

export interface TagEdgePromise extends Promise<TagEdge>, Fragmentable {
  node: <T = TagPromise>() => T;
  cursor: () => Promise<String>;
}

export interface TagEdgeSubscription
  extends Promise<AsyncIterator<TagEdge>>,
    Fragmentable {
  node: <T = TagSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Story",
    embedded: false
  },
  {
    name: "Chapter",
    embedded: false
  },
  {
    name: "User",
    embedded: false
  },
  {
    name: "Tag",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
